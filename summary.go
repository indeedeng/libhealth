package libhealth

import (
	"net/http"
	"time"

	"github.com/emirpasic/gods/sets/hashset"
)

// Summary is for representing the result of running multiple Checker instances
// such as the ones kept by a Dependencies. This object is intended to be used
// by a Dependencies for generating specified JSON output.
type Summary struct {
	executed time.Time
	results  []Result
}

// NewSummary will create a new Summary for a list of Health responses.
func NewSummary(executed time.Time, results []Result) Summary {
	return Summary{
		executed: executed,
		results:  results,
	}
}

// Result represents the final result of a HealthChecker. It contains
// all the information needed before being consumed by a robot.
type Result struct {
	Health
	docurl   string
	desc     string
	lastGood time.Time
	period   time.Duration
	name     string
}

// Executed returns the time at which s was generated by initiating
// the checks it represents.
func (s Summary) Executed() time.Time {
	return s.executed
}

// Overall will return the combined downgraded Status of all of the Health instances.
// This state depends on both the check status and the urgency of each of the Health instances.
func (s Summary) Overall() Status {
	if len(s.results) == 0 {
		return OK
	}

	lowest := OK
	for _, d := range s.results {
		h := d.Health
		s := h.Status
		downgraded := h.Urgency.DowngradeWith(lowest, s)
		if downgraded.SameOrWorseThan(lowest) {
			lowest = downgraded
		}
	}

	return lowest
}

// Status will return the combined downgraded Status of all of the Health instances identified by name
// The state does NOT depend on the urgency of each of the Health instances
func (s Summary) Status(names ...string) Status {
	if len(s.results) == 0 {
		return OK
	}
	lowest := OK
	set := hashset.New(variadic(names)...)
	for _, d := range s.results {
		if !set.Contains(d.name) {
			continue
		}
		s := d.Health.Status
		if s.SameOrWorseThan(lowest) {
			lowest = s
		}
	}
	return lowest
}

// StatusWithUrgency will return the combined downgraded Status of all of the Health instances identified by name
// This status depends on both the check status and the urgency of each of the Health instances.
func (s Summary) StatusWithUrgency(names ...string) Status {
	if len(s.results) == 0 {
		return OK
	}
	lowest := OK
	set := hashset.New(variadic(names)...)
	for _, d := range s.results {
		if !set.Contains(d.name) {
			continue
		}
		h := d.Health
		s := h.Status
		downgraded := h.Urgency.DowngradeWith(lowest, s)
		if downgraded.SameOrWorseThan(lowest) {
			lowest = downgraded
		}
	}
	return lowest
}

// Duration is a method provided to determine the total
// length of time it took to compute a Summary - that is how long it took to run
// a set of Checkers and produce results.
func (s Summary) Duration() time.Duration {
	earliestStart := time.Date(9999, 0, 0, 0, 0, 0, 0, time.UTC)
	latestFinish := time.Date(2000, 0, 0, 0, 0, 0, 0, time.UTC)

	for _, d := range s.results {
		startTime := d.Health.Time
		endTime := startTime.Add(d.Health.Duration)
		if startTime.Before(earliestStart) {
			earliestStart = startTime
		}
		if endTime.After(latestFinish) {
			latestFinish = endTime
		}
	}
	return latestFinish.Sub(earliestStart)
}

// ComputeStatusCode returns the HTTP status code representative of the status.
// The public info endpoints return HTTP 500 internal server error if the component is in outage.
// Otherwise, any lessor status returns HTTP 200 ok.
// The private endpoints conversely return a HTTP 200 ok if and only if the overall state is ok.
// Any unhealthy state will return an HTTP 500 internal server error.
func ComputeStatusCode(info bool, s Summary) int {
	if info {
		if s.Overall() == OUTAGE {
			return http.StatusInternalServerError
		}
		return http.StatusOK
	}
	if s.Overall() == OK {
		return http.StatusOK
	}
	return http.StatusInternalServerError
}

func variadic(slice []string) []interface{} {
	variadic := make([]interface{}, 0, len(slice))
	for _, s := range slice {
		variadic = append(variadic, s)
	}
	return variadic
}
